#单例模式

单例模式应该是我及大多数Java程序员最早接触的设计模式之一，也是最常用的设计模式之一。

###是什么？

单例模式是确保一个类只有一个实例，并提供一个全局访问点的一个模式。

###作用及应用场景
在Java应用中，单例模式能保证在一个JVM中，该单例对象只有一个实例存在。
应用场景如下：
1. 在开发中，有一些对象可能我们只需要一个，例如：线程池、缓存、日志对象、一些操作系统设备的类。
2. 相比于用new关键字创建多个对象，能降低系统开销，减轻jvm压力。

但是，为什么不能用其他东西替代单例（比如，用程序员间的约定替代单例，又比如，Java.lang.Math类是采用静态方法类而非单例的方式实现的？），为什么要用单例？

第一，单就这个事例看，单例模式比约定好，单例模式付出的代价仅仅是代码上的，而且单例却能避免约定中会产生的很多问题。
第二，单例模式与静态类的对比，网上说法众说纷纭，而且有不少是有问题的。我的看法如下。

####单例模式和静态类对比
|       | 单例模式 | 静态类  |
| :---: | :---: | :---: |
| 典型例子 | java.lang.Runtime | java.lang.Math |
| 存储区域 | 永久代（PermGen） | 永久代（PermGen） |
| 初始化时间点 | 用到时创建 | 加载时创建 |
| OOP（主要） | 可以实现接口；在外部能作为其他类的属性或方法参数 |   |
注：
* 存储区域的特指在jdk 1.6下 [ [1] ](#references)，我这里先挖个坑，就我所知，大小是差不多，但引用是否也在PermGen，而且不同版本jvm的存储位置在哪，这个点我没实测且影响不大，留待我以后可能学jvm时再填坑。
* 初始化时间点中仅针对主流用法，单例的时间点也要取决于具体哪种单例，而静态类的加载其实与具体jvm的实现有关，某些jvm是在用到时才创建的。


###




### References
[1] [ 知乎|方法区的Class信息,又称为永久代,是否属于Java堆？ ](https://www.zhihu.com/question/49044988)